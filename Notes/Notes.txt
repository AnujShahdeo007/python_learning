Data Structures
------------------
A data structure is way of oranizing,storing and managing data in program. 

Problem without DS 

1. Code become slow 
2. searcing data is difficult 
3. maganaing data is messy 

List
------
A list is an ordered, mutable (changable) collection that can store multiple values, even of difrenet data types.

num=[10,20,30]
mixed=[1,"abc",True,3.5]
nested=[[1,2],[3,5]]

Key properties

Ordered: Keeps position (index)

Indexed: start from 0

Mutable: you can update/add/remove items 

Allow Duplicates: [1,1,2] is valid 

Can nest lists: list inside list 

indexing 

Indexing means accessing a single elements from a list using its position

Negative Indexing 
--------------------

Negative indexing starts from end of the list  ( Always start with -1 )


List Slicing 
------------

slicing is used to extarct multiple elements from a list.

Syntax: list[start:end:step]


Q. Why end index is excluded? 

---------------------------------------------------------------------------------------------------------------------------------------
List : Adding Elements 

There are 3 main ways :

1. append() - Rule: Append() always adds ONE objects whatever that object is.
2. extend()
3. insert()

features        Append              extend                  insert 
Adds            1 element           many elements           1 element 
Position        end                 end                     Specific index 
Iterable        No                  Yes                     No
Performance     Fastest             Fast                    Slow 
Real Use        logs,loops          batch merge             ordering 


Removing Elements 
--------------------
1. remove(value)
   - You give a value 
   - Python searches from left to right 
   - Remove the first occurence 
   - If value not - Error 
2. pop ()
    - Remove item at give index 
    - Return the removed item 
    - Default index is -1 ( last item )
    - If index invalid : IndexError 

3. del ( Delete by Index or Slice )
    - del - keyword, not a list method 
    - it can delete:
        - single element 
        - range of element (slice)
        - even the whole list variable

4. clear() - Remove eveerything (empty list)
    - Empties the same list object 
    - List become []

Operations      Removed By          Removes how many        Return          Error cases 
remove(x)        value              first match only         No             ValueError
pop(i)           index              one item.                Yes.           IndexError if out of range 
del a[i].        index/slice.       one or many              No             Index Error if out of range 
clear().         none               all                      No             No 


List & Operations and Built In functions  :

1. Basic Operators = (+,*,in,not in )

  + (Concatenation) -> Join two lists 
    - + creates a new list by combining two lists 
    - It does not modify the original list 
    - Works only with 2 lists 

  * (Repetation) - Repeat list items N times 
    - lst * n - Repeats the list n items and create a new list 
    lst=[1,2]
    print(lst*3)
    [1,2,1,2,1,2]

  in (membership) - Is item present?

    - x in lst checks if x exists in list 
    - Return True/False 
    - For Lists, it does a liner search (O(n))
    lst=[10,20,30]
    print(20 in lst) ---  True 
    print(40 in lst) --- false 

   not in - Is item not present?
   lst=[1,2,3]
   print(5 not in lst)

2. Core built ins : ( len, max, min, sum )

    len - Length/Count of elements 
        - len() returns the number of elements in a list 
        - it does not care about values, only count 

        lst= [10,20,30]
        len(lst) =3 
    Important Note:
        - Counts elements, not Memory 
        - Nested list counts as one element 
        lst= [1,2,[3,4]]
        len(lst)- 3 

    max - Largest Element 
        - Return the maximum element 
        works on :
            - numbers 
            - Strings 
    min - Samallest Element 
        - Opposite of max()
        - Same rules 
        min([10,20,30]) ---> 10 
        min(["apple","bat"]) - 'apple'
        words=["a","bbb","cccc"]
        min(words,key=len) --> 'a'
    
    sum() - Total of numeric elements 
        - Adds all numeric elelemnts 
        - Oprtional- second argument - startting value 
        sum([1,2,3])
        sum([1,2,3],10)

3. Sorting : ( sort, sorted,key,reverse)
    sort - Sorting means arranging elelemnts in specific order.
         - Ascending 
         - Descesning 
         - Custom order ( length,last digit, date)
        sort() - 
        nums=[3,1,2]
        nums.sort() # [1,2,3,]

     sorted - Create a list 
        - Original list remain unchanged
        - Return a new sorted list 
        nums=[3,1,2]
        nums_sorted=sorted(nums)

     reverse=True - Descending order 
        - Default sorting is ascending 
        - reverse=True flip the order 
     nums=[5,1,4,2]
     nums.sort(reverse=True)
     print(nums)
     [5,4,2,1]

     nums=[5,1,4,2]
     print(sorted(nums,reverse=True))
     [5,4,2,1]

    Key - Custom sorting 

        - key decides ON what basis sorting happens
        - It takes a function 
        - That function runs on each element 
        - Python sorts based on returned value 
    words=["apple","kiwi","banana","fig"]
    words.sort(key=len)
    ["fig"]

    data=[(1,3),(4,1),(2,2)]


4. Common list methods : (count,index,copy)

list.count(value).  ------Return integer
    - count() - How many times an element appers 
     - count() tells how many times a value exists in list 
    - It does not modify the list 
    Return an interger
    list.count(value)
nums=[1,2,3,4,5,5,5,5]
print(nums.count(5))

names=["ram","ram","aaa","bbbb"]
print(names.count("ram"))

nums=[1,2,2,3,3,3,3,3,3,4,5,5,5,5]
count=0
for x in nums:
    if x==5:
        count += 1
print(count)

max_count=0
max_element=None 

for i in range(len(nums)):
    count=0
    for j in range(len(nums)):
        if nums[i] == nums[j]:
            count += 1
    if count > max_count:
        max_count=count
        max_element=nums[i]
print(max_element)




Index(): Find Position of an elelemnt

    - index() returns the position (index) of the first occurence.
    - if element not found - Error 
    - index always start with 0 

    list.index(value) 

    nums=[10,20,30,30,40]
    print(nums.index(30))
    2 

    print(nums.index(50))

    valueError : 50 is not in list 

Copy - Shallow copy of List 

    - copy() creates a new list 
    - Data is same, but memeory is diffrent
    - Used to avoid accidental data change 

    new_list=old_list.copy()

    a=[1,2,3]
    b=a.copy()

    b.append(4)

    print(a)
    print(b)

    --------------

    Without using copy 

    a=[1,2,3]
    b=A
    b.append(4)
    print(a)
    print(b)


5. Iteration utilities : (enumerate,zip)

    - enumerate() gives index and value togatrher 
    - cleaner,readbale 
    - Returns pairs (index,element)

    enumerate(Iterable,start=0)

    for i,name in enumerate(names):
    print(i,name)

    Zip() - Combine elements from multiple iterables 
    - Return pairs (or tuple)
    - Stops at shortest iterbale 

    zip(iterable1,iterable2,.........)

    names=["Amit","Neha","Ravi"]
    marks=[85,90,78]

    for name,mark in zip(names,marks):
        print(name,mark)

6. functional : (any,all,map,filter)
any () - Check if at least one is true 
    - any() return true if any one element is truthy
    - Return False only if all elelmts are False 
    - Work with Iterable (List,tuple)

    nums=[0,4,0,0]
    print(any(nums)) ---> true
    nums=[0,False,None] ----> False 
    any(iterable)

    one True    True 
    All False   False 
    Empty List  False 

    any([5,0,"",None,5])
    5 -> True Stop 
    0 -> False 
    ""-> False 
    None-> False 
    5 -> True STOP 

    login_attemps=[False,False,False ]
    any([login_attemps]) ---->False 

all() - Check if eveything is true 
    all() retrun true only if all elemts are truthy 
    Retrun False if any one element is false 

    all(iterable)

    nums=[1,2,3]
    print(all(nums)) ----True 

    nums=[1,0,3]
    print(all(nums)) -----> false 

    fields=["name","email",""]
    print(all(fields))

    All true ---True 
    One False --- False 
    Empty list -- True 

    all(x>0 for x in [1,2,0,4])

    1>0 --True 
    2>0 ---True 
    0>0 ---False ----STOP 




map() - Apply Function to every element (Lazy Evalution)

    - map() applies a function to each elelemnt
    - retrun a map object (covert to list to get output)
    - Used Transormataion 


    map(function,iterable)

    nums=[1,2,3,4]
    result=map(lambda x:x*x,nums)

    Note: Return Map --- To see the output we need convert it to List 

filter() - Select Elements based on condition 

    - filter() keeps elelemts where condition is True
    - Used for filtering/removing unwanted data 
    
    filter(function,iterable)

    nums=[1,2,3,4,5,6,7,8,9]
    even=filter(lambda x:x%2==0,nums)
    print(list(even))

    map()            and        Filter()
    Transfrorm                  select 
    same as input               samller or equal 
    Not requied                 Required 
    Modify data                 Remove Data 


 any()- Existence check 
 all()- Universal check 
 map()- transformation 
 filter- selection 
 ---- All are lazy,efficient and expressive 



7. Conversion & useful patterns : ( list(),join,flatten,dedupe)

    list() - Conversion pattern 
    - convert an iterable into list 
    - common Sources - map,filter,zip,range,generator experssion 

    name=["Amit","Neha"]
    marks=[80,90]
    pairs=list(zip(name,marks))
    print(pairs)

Join() - Join itrable of string ( String Joining pattern)
    - Join iterable of trings into single string 

    words=["Python","is","awesome"]
    senetence=" ".join(words)
    print(senetence)
"seperator".join(iterable of string)

Flatten- Nested Data Pattern 
    - Convert nested list ---- Flat List 
    - Converting nested structures into single level 

    2D list --> 1D 
    3D lis---> 1D 
    N-D list--> 1D (recursive)
    matrix=[[1,2],[3,4],[5,6]]
    [1,2,3,4,5,6]

    Used:
    - api
    - Spark/Pandas 
    - JSon 

    1st Pattern
    -----------

    matrix=[[1,2],[3,4],[5,6]]

    flat - [1,2,3,4,5,6]
    flat=[x for row in matrix for x in row ]

    flat=[]
    for row in matrix:
        for x in row:
            flat.append(x)


cube=[
    [[1,2],[3,4]],
    [[5,6],[7,8]]
]

flat=[]
for layer in cube:
    for row in layer:
        for x in row:
            flat.append(x)

flat=[x for layer in cube for row in layer for x in row]

data=[1,[2,[3,4],5],[[6]],7]
data=[1,2,3,4,5,6,7]

    Pattern -2 
    -----------

matrix=[
    [1,2,3],
    [4,5,6],
    [7,8,9]
]

a=[1,2,3]
a.append(4) 

a=[1,2,3]
a.extend([4,5])
print()

matrix=[[1,2],[3,4]]

flat=[]
for row in matrix:
    flat.append(row)
print(flat)

Using Extend 
----------
flat=[]
for row in matrix:
    flat.extend(row)
print(flat)


Pattern -3 
-----------

Use itertools.chain 
--> Take multiple iterables and chain them one after anothe.

Itertools.chain is a tool that links multiple iterables togather and lets you iterate over them as if they were one sequence.

Module: itertools
Nature: iterator(lazy,memeory-efficient)

from itertools import chain 
a=[1,2]
b=[3,4]
c=[5,6]
result=chain(a,b,c)
print(list(result))

------> Chain did not create a new list immediatly it yieled eleents on by one 


chain() vs chain.from_iterable
-------------------------------

chain() - Use when you already have separte iterables 

chain.from_iterable - Use when you have one iterable that contains other iterables (like 2D)

matrix=matrix=[[1,2],[3,4]]

flat=list(chain.from_iterable(matrix))

chain([1,2],[3,4])

---------------------------------------------
flat=list(chain(*matrix))
print(flat)

Why Not use (chain(*matrix))
------------------------------

Uses unpacking ---> high meory for large lists 



Internally
-----------
for row in matrix:
    for x in row:
        x


matrix=[
    [1,2,3],
    [4,5,6],
    [7,8,9]
]

from itertools import chain 
flat=list(chain.from_iterable(matrix))
print(flat)

flat=list(chain.from_iterable(matrix))
----------------------------------------------------------------------------------

Dedupe - Remove duplicates 

Deduplication removes repated values 
two types:
    - Order not important 
    - Order must be preserved (Very common)

data=[1,2,2,3,4,5]
unique=list(set(data))

nums=[1,2,2,3,1,4]

[1,2,3,4]

Why Duplicate happen:
- Same data loaded twice 
- File Reprocessed 
- API retries
- User submits form again 
- System Failure 


1. Set() - Order is lost 


nums=[1,2,2,3,1,4]
deduped= list(set(nums))

[1,2,3,4]

Output 
-------
Order is not gaurenteed 

2. nums=[1,2,2,3,1,4]

deduped= list(dict.fromkeys(nums))


How dict.fromkeys() works:

{
    1: NONE,
    2:NONE,
    3:NONE,
    4:NONE,
}

list(dict.keys())


nums=[1,2,2,3,1,4]

Loop ---> Check ----> add ---> skip duplicate 

---------------------------------------------------------------------------------------------------------------------------------------


Tuple
------

A tuple is an ordered collection of items. But immutable

Why tuple exist if we already have List
---------------------------------------
Safer - Data con't be changes accidently 
Faster then list many operations
Hashable ( It can used as Dictionary key if eleents are Hashable)
Good for fixed records 

How to create tuple:
--------------------
Case A: Normal tuple:

t=(10,20,30)
print(t)

Case B: Without brackets (tuple packing)
t=10,20,30
print(t). -----> (10,20,30)

Case:c Single eleents tuple 

t1=(5) ----> Not a tuple (its INT)
t2=(5,) ---> Tuple

Rule: single item tuple must have comma 

CASE :D Empty tuple 

t=() 

CASE : E  ---> tuple() constructor 

t=tuple([1,2,3,4])
t2=tuple("python")

Notes: tuple() ---> Converts any iterables into a tuple.

Tuple properties
----------------
- Ordered 
- Allow Duplicates 
- Can store mixed types 
- immutable

t=(1,1,"a",True,3.5)
--------------------------------------------------------
Accessing tuple (Indexing+slicing)

t=(10,20,30,40)
print(t[0]) #10
print([-1]) #40

print(t[1:3]) # (20,30)
print(t[:2]) # (10,20)


Nested tuple access 
-------------------
t=(1,(5,6),3)

print(t[1][0])  # 5

Immutability
--------------

t=(10,20,30)
t[0] =99 # TypeError 

--------------------------But inside Object can change---------------------
t=(1,[10,20],3)
t[1].append(30)
print(t)

If tuple contains a mutable onjects(list) the list can change 

Tuple itself didn't change (still 3 items ) but inner list changed.


Tuple Operations 
-----------------

Concatenation:
    (1,2)+ (3,4) -----> (1,2,3,4)

Repetation:
    (1,2) *3 ----> (1,2,1,2,1,2)

Membership: 

    2 in (1,2,3,4,5) # True 

Iteration:

    t=(10,20,30)

    for tx in t:
        print(tx)

Tuple Functions and Methods 
---------------------------

t=(1,2,2,3)

t.count(2) # 2
t.index(2) # 1 (First occurence)

Built function
-------------

len(t)
min(t) max(t)
sum(t)
sorted(t) -> gives list -----> tuple(sorted(t))

Tuple Packing (What + Why)

Tuple packing: Python automatically groups multiple values into one one table 

t=10,20,30
print(t). -------> (10,20,30) 
type(t) ----> tuple 

Key Point
--------
- Comma,creates the tuple not parentheis 
- Parenthesis are optional unless needed for clariry

Unpacking 
-----------
t=(10,20,30)
a,b,c=t

*********************************************************************************************************************
*                                                Set                                                                *
*********************************************************************************************************************

What is SET?

A set is a collection of unique values stored without order.
my_set={1,2,3}

Unordered       No fixed position 
unique          No duplicate value 
Mutable         Can add/remove values 
No indexing     cannot use s[0]

rolls=[101,102,103,101,104] # Duplicate roll no.

unique_rolls=set(rolls) #{101,102,103,104} 

# Set automiatically removes duplicate.


How set is created:
-------------------

1. using {}

s={1,2,3}

2. using set() constructor 

s=set([1,2,3])


empty={} # Not a set
type(empty) # dict


empty_set=set()


{} is always a dictionary, never a set

Set internal working & How does set removes duplicate
-------------------------------------------------------
s={10,20,10,30,30}

Internal steps:
1. Python uses hashing 
2. each element --> hashed 
3. If hash already exist --> Ignore 

That's why set is FAST (O(1)) lookup.


s={10,20,30}
print(s)

{20,10,30}
{30,30,10}

Order is gaurenteed. 

bcz:- 1. Set is based on has code hash not equal index 

s={10,20,30}

s[0] -> Error 
--------------------------------------------------------------------------------------------------------------
s={10,20,30}

1. ADD/inset 

    - add(x) - Add a single element 

2. update(iterable)
    - Add multiple elements from any iterables (list,tuple,string)
    s.update([4,5,6]) #
    s.update("ab) # 'a','b'
    - When you want to merge many items 

3. Remove/Delete
    - remove(x)
    s.remove(4) 
    s.remove(99) # KeyError

4. discard(x) - Remove element safley (No error if element is missing)

5. pop() - Remove and return some element 
        - You cannot predict which element is removed.

Why Pop() behave like this?
    - Sets are implemented using hash tables.
    - Elements are placed nased on hash value 
    - There is no sequence or index 

6. clear() - Remove eveything
    s.clear()

7. copy() 
    - Return a shallow copy of the set.
    s={1,2,3}
    t=s.copy()
    t.add(99)
    print(s) #{1,2,3}
    print(t) #{1,2,3,99}

    When you want to try transformation without touching original.

s={1,2,[3,4]}

8. union - All unique values from both the sets  (a|b)
    a={1,2,3}
    b={3,4,5}
    print(a.union(b)) 

9. intersection (a&b) - Common elemnts only 
    print(a.intersection(b))

10. difference (a-b) - Element in a not in b 
    print(a.difference(b))

11. symmetric_diffrence - Element that are in either set but not common.
    print(a.symmetric_difference(b))

12 union_update - a.update(b)   a |=b 

13. intersection_update -  keep only common in a 
    a={1,2,3}
    a.intersection_update({2,3,4}) --> {2,3}
14. isdisjoint() 
    - True if no common elemnts 
    print({1,2}.isdisjoint({3,4})) - True
    print({1,2}.isdisjoint({2,4})) - False 
15. issubset() - True if all elelemnts of set exist in other 
    print({1,2}.issubset({1,2,3})) - True 
16. issuperset() - true if set contains all elelemnts of others 
    print({1,2,3}.issuperset({1,2})) - True 




*********************************************************************************************************************
*                                          Dictionary                                                               *
*********************************************************************************************************************


A dictionary stores data in key:value pairs.

students={
    "name":"abc",
    "age":25,
    "city":"Pune
}

name - Key 
abc - value 

students=["abc",25,"Pune"] 

index 0 - Name 

students[name] # abc 
students[age] #25 

properties              Meaning 

key-value               Data stored as pairs 
keys unique             No duplicates keys allowed 
Value any type          
Mutable 
Fast lookup             Hashing 
Ordered( py 3.7)        Insertion order preserved 

Creating a Dictionary 
--------------------

d={"a":1,"b":2,"c":3}

d=dict(name="abc",age=25)

pairs=[("a",1),("b",2)]
d=dict(pairs)


students["name"] 

studnets=["sala"] # Key error 

Methods :

1. keys() :
    - d.keys() gives you all the keys of a dictionary.

    d={"a":1,"b":2,"c":3}

    d.keys()

    What exactly is dict_keys()
                Note: It is not a list
        - It is a view - 
        - It shows keys without copying them into a new list 
        - It satys connected to the dictionary.

        Note: If dictionary changes, this view also change 

2. Values() : 
    - d.values() return all the values stored in dictionary.

    d={"a":1,"b":2,"c":3}
    v=d.values()
    print(v)

    Note: This is not a list 
    This is view object 

3. items() 
    - d.items() - returns both key and value togather as pair.

    d={"name":"Raj","age":30,"city":"Pune"}
    it=d.items()
    print(it)

without items()

    for k in d:
        print(k,d[k])

4. get() - get() used to safely read the value from dictionary
    value=d.get(key)

    d={"name":"Raj","age":30,"city":"Pune"}
    print(d["sal])

    print(d.get("sal))

    get(key,default)

    if key exists- return value 
    if not -> return the default 

    Q.1 Frequency counting 

    logs=["A","B","A","C","A"]

    {"A":3,"B":1,,"C":1}

    freq={}
    for x in logs:
        freq[x]=freq.get(x,0)+1
    print(freq)

    Q2. payload={"user":{"name":"Raj"}} -> if key is exist return value if key not exists return UNKNOWN 

    5. update()
    - add new keys 
    -change existing keys 
    - merge one dictionary into another 

    d= {"A":3,"B":1,,"C":1}
    d.update({"C":31,"City":"Pune"})
    print(d)

    key exists -> overwrite value 
    key does not exists-> add new key 


6. setdefault()  - >If this key exists, return its value and if it is not exists create it with a default value 

    dict.setdefault(key,default)

    d= {"A":3,"B":1,,"C":1}
    c={}
    c.setdefault("age",30)

    NOTE: setdefault() never overwrites existing key.

Q. orders=[
    ("A",100),
    ("B",200),
    ("A",50),
    ("C",300),
]


{"A":[100,50],"B":[200],"C":[300]}




*********************************************************************************************************************
*                                        String Operations                                                          *
*********************************************************************************************************************


What is string?

    - A string is a sequence of character enclosed in quotes 

    a="python"
    b="data"
    c=""" multi line string"

    - Store name,text,logs 
    - File handling 
    - API 
    - SQL queries 
    - JSON/CSV 


    2. String Immutability:

        - Once created a string cannot be changes 

        s="hello"
        s[0]="H" (Not allowd )

    Create Sting 
    -----------
    "a"
    "b"

    Triple Quotes :

    msg= """ hello
    python 
    hi 
    java"""


    Escape chanrcters
    -----------------

    \n  new line 
    \t  tab
    "   quote 
    \   backslash 




    s="PYTHONPROGRAMMING"

    s[::2] # PHPGMN PTOPORMIG

    s[::-1] # 

    s[6:13] # PROGRAM

    s[12:6:-1] # MARGOR

    s="PYTHONPROGRAMMING"

    s[1:15:3] # THPGM

    s[::-2] # GIMROPOTP # GNMROPNTP


    s[3:10:-1] # 

    s[-5:-1] # 

    s="ABCDEFGHIJK"

    print(s[8:2:-2]) # 



    1. lower() 
        convert all charcters to lowercase 

        s="Python"
        print(s.lower()) # python 

    2. upper()

    3. title() 
        - Capitalize first letter of each word 
        "data engineering course".title()

    4. Capitalize() 
        - Only first charcter uppercase 
    5. swapcase() 
        - Lower-> upper and upper to lower 

    6. Strip/trim (data cleaning )

        - Remove unwanted chacters from ends 

        "hello   ".strip() 

        Removes the spaces from both side 

        - lstrip() 
        - rstrip() 

    "******hello*******".strip("*") # hello 

    Searching Methods 
    ----------------

    1. find() : Return index on substring 

    "python".find("th") # 2

    if not found : return -1 

   2.  index() - Same as find but throw error 

   3. count() - Count occurance 

Replace methods 
---------------

replace(old,new ) 

"I love Java".replace("Java","Python")

Split and join 
---------------

split() : Breaks string into list 

    "a,b,c".split(",") 

    Note:

    "Hello   Spark".split()

rsplit() : Splits from right side 

    "a,b,c".rsplit(",",1)

splitlines() : Split based on newline 

"Hello\nPython".splitlines()

Join 
=====

Join list into string 

"-".join(["a","b","c"])

# a-b-c 


formate() 
----------
"Hello {}".formate("Python")

"{} {}".format("Data","Engineering")


startwith() & endswith()
------------------------
"python".startwith("py")

"file.csv".endswith(".csv")


email="      hello.Python@GMAIL.com     "

clean_email=email.strip().lower()


log= "ERROR|2026-02-16|Timeout occured"

parts=log.split("|")

level=parts[0]
data=parts[1]
msg=parts[2]

file_name="data_2026.csv"

if file_name.endswith(".csv"):
    print("Process file")
else:
    print("File is not CSV")


Q. 1

["Raj","28","Pune"]

row="    Raj , 28 ,Pune "

Q.2 

name="Raj"
city="Pune"

msg=

User Raj logged in from city Pune 

Q.3 

"Hello      Python          Students"

output :

Hello python Students 


Q.4 

table="emp"

query = 

Select * from emp;

























































---------------------------------------------------
index 0     1   2   3
Nums  5     1   4   2

Rule: Compare left number with right number 
If left>right---> Swap 

ROUND -1 

We compare all neighbors 

Step 1 : Compare index 0 & 1 

5  1   4   2
-  -

5>1--> true ---> Swap 

[1  5   4   2]

Step: compare index 1 & 2 

1  5   4   2
   -   - 

5 > 4 --> true ---> Swap 

[1  4   5   2]


Step 3 : Compare 2 & 3 

1  4   5   2
       -   - 
5>2 -- True --- Swap 

[1  4   2   5 ]

-> End of round 1 
-> Biggest number 5 moved to the end 


ROUND 2 (i=1)

ignore last element ( Already sorted)

step 1: comapre index 0 & 1 

1   4   2   5
-   -

1 > 4 --> False ---> No Swap 

[1  4   2   5]

Step 2 : Comapre index 1 & 2 

1   4   2   5
    -   -

4 > 2 --- True --  Swap 

[1  2   4   5]

End of Round 2 

[1  2   4   5]


ROUND 3 : (i=2)

Only First two elements need check 

Step 1 ; Comapre index 0 & 1 

1   2   4   5
-   -

1 > 2 --- False ---> no Swap 


[1   2   4   5]


ROUND 4 ( i=3 )

No Comaparision requied 



Final Result [1   2   4   5]



why n-i-1 


--> After each round, elements at the risght end are fixed 

round 1 [?  ?   ?   5]

round 2 [?  ?   4   5]

round 3 [?  2   4   5].  ------> We stop checking those fixed position 


Comapre neighbors ----> Swap ----> Reapt 
Big number move it right 

Samll number move left 


1. Bubble Sort 

2. Selection sort 

3. Insertion sort 

4. Merge sort 

5. Quick sort 

6. Heap sort 


lst=[[1,2,3],[4,5,6],[7,8,9]]
print(lst[0:1][0])




