Data Structures
------------------
A data structure is way of oranizing,storing and managing data in program. 

Problem without DS 

1. Code become slow 
2. searcing data is difficult 
3. maganaing data is messy 

List
------
A list is an ordered, mutable (changable) collection that can store multiple values, even of difrenet data types.

num=[10,20,30]
mixed=[1,"abc",True,3.5]
nested=[[1,2],[3,5]]

Key properties

Ordered: Keeps position (index)

Indexed: start from 0

Mutable: you can update/add/remove items 

Allow Duplicates: [1,1,2] is valid 

Can nest lists: list inside list 

indexing 

Indexing means accessing a single elements from a list using its position

Negative Indexing 
--------------------

Negative indexing starts from end of the list  ( Always start with -1 )


List Slicing 
------------

slicing is used to extarct multiple elements from a list.

Syntax: list[start:end:step]


Q. Why end index is excluded? 

---------------------------------------------------------------------------------------------------------------------------------------
List : Adding Elements 

There are 3 main ways :

1. append() - Rule: Append() always adds ONE objects whatever that object is.
2. extend()
3. insert()

features        Append              extend                  insert 
Adds            1 element           many elements           1 element 
Position        end                 end                     Specific index 
Iterable        No                  Yes                     No
Performance     Fastest             Fast                    Slow 
Real Use        logs,loops          batch merge             ordering 


Removing Elements 
--------------------
1. remove(value)
   - You give a value 
   - Python searches from left to right 
   - Remove the first occurence 
   - If value not - Error 
2. pop ()
    - Remove item at give index 
    - Return the removed item 
    - Default index is -1 ( last item )
    - If index invalid : IndexError 

3. del ( Delete by Index or Slice )
    - del - keyword, not a list method 
    - it can delete:
        - single element 
        - range of element (slice)
        - even the whole list variable

4. clear() - Remove eveerything (empty list)
    - Empties the same list object 
    - List become []

Operations      Removed By          Removes how many        Return          Error cases 
remove(x)        value              first match only         No             ValueError
pop(i)           index              one item.                Yes.           IndexError if out of range 
del a[i].        index/slice.       one or many              No             Index Error if out of range 
clear().         none               all                      No             No 


List & Operations and Built In functions  :

1. Basic Operators = (+,*,in,not in )

  + (Concatenation) -> Join two lists 
    - + creates a new list by combining two lists 
    - It does not modify the original list 
    - Works only with 2 lists 

  * (Repetation) - Repeat list items N times 
    - lst * n - Repeats the list n items and create a new list 
    lst=[1,2]
    print(lst*3)
    [1,2,1,2,1,2]

  in (membership) - Is item present?

    - x in lst checks if x exists in list 
    - Return True/False 
    - For Lists, it does a liner search (O(n))
    lst=[10,20,30]
    print(20 in lst) ---  True 
    print(40 in lst) --- false 

   not in - Is item not present?
   lst=[1,2,3]
   print(5 not in lst)

2. Core built ins : ( len, max, min, sum )

    len - Length/Count of elements 
        - len() returns the number of elements in a list 
        - it does not care about values, only count 

        lst= [10,20,30]
        len(lst) =3 
    Important Note:
        - Counts elements, not Memory 
        - Nested list counts as one element 
        lst= [1,2,[3,4]]
        len(lst)- 3 

    max - Largest Element 
        - Return the maximum element 
        works on :
            - numbers 
            - Strings 
    min - Samallest Element 
        - Opposite of max()
        - Same rules 
        min([10,20,30]) ---> 10 
        min(["apple","bat"]) - 'apple'
        words=["a","bbb","cccc"]
        min(words,key=len) --> 'a'
    
    sum() - Total of numeric elements 
        - Adds all numeric elelemnts 
        - Oprtional- second argument - startting value 
        sum([1,2,3])
        sum([1,2,3],10)

3. Sorting : ( sort, sorted,key,reverse)
    sort - Sorting means arranging elelemnts in specific order.
         - Ascending 
         - Descesning 
         - Custom order ( length,last digit, date)
        sort() - 
        nums=[3,1,2]
        nums.sort() # [1,2,3,]

     sorted - Create a list 
        - Original list remain unchanged
        - Return a new sorted list 
        nums=[3,1,2]
        nums_sorted=sorted(nums)

     reverse=True - Descending order 
        - Default sorting is ascending 
        - reverse=True flip the order 
     nums=[5,1,4,2]
     nums.sort(reverse=True)
     print(nums)
     [5,4,2,1]

     nums=[5,1,4,2]
     print(sorted(nums,reverse=True))
     [5,4,2,1]

    Key - Custom sorting 

        - key decides ON what basis sorting happens
        - It takes a function 
        - That function runs on each element 
        - Python sorts based on returned value 
    words=["apple","kiwi","banana","fig"]
    words.sort(key=len)
    ["fig"]

    data=[(1,3),(4,1),(2,2)]


4. Common list methods : (count,index,copy)

list.count(value).  ------Return integer
    - count() - How many times an element appers 
     - count() tells how many times a value exists in list 
    - It does not modify the list 
    Return an interger
    list.count(value)
nums=[1,2,3,4,5,5,5,5]
print(nums.count(5))

names=["ram","ram","aaa","bbbb"]
print(names.count("ram"))

nums=[1,2,2,3,3,3,3,3,3,4,5,5,5,5]
count=0
for x in nums:
    if x==5:
        count += 1
print(count)

max_count=0
max_element=None 

for i in range(len(nums)):
    count=0
    for j in range(len(nums)):
        if nums[i] == nums[j]:
            count += 1
    if count > max_count:
        max_count=count
        max_element=nums[i]
print(max_element)




Index(): Find Position of an elelemnt

    - index() returns the position (index) of the first occurence.
    - if element not found - Error 
    - index always start with 0 

    list.index(value) 

    nums=[10,20,30,30,40]
    print(nums.index(30))
    2 

    print(nums.index(50))

    valueError : 50 is not in list 

Copy - Shallow copy of List 

    - copy() creates a new list 
    - Data is same, but memeory is diffrent
    - Used to avoid accidental data change 

    new_list=old_list.copy()

    a=[1,2,3]
    b=a.copy()

    b.append(4)

    print(a)
    print(b)

    --------------

    Without using copy 

    a=[1,2,3]
    b=A
    b.append(4)
    print(a)
    print(b)


5. Iteration utilities : (enumerate,zip)

    - enumerate() gives index and value togatrher 
    - cleaner,readbale 
    - Returns pairs (index,element)

    enumerate(Iterable,start=0)

    for i,name in enumerate(names):
    print(i,name)

    Zip() - Combine elements from multiple iterables 
    - Return pairs (or tuple)
    - Stops at shortest iterbale 

    zip(iterable1,iterable2,.........)

    names=["Amit","Neha","Ravi"]
    marks=[85,90,78]

    for name,mark in zip(names,marks):
        print(name,mark)

6. functional : (any,all,map,filter)
any () - Check if at least one is true 
    - any() return true if any one element is truthy
    - Return False only if all elelmts are False 
    - Work with Iterable (List,tuple)

    nums=[0,0,5,0]
    print(any(nums)) ---> true
    nums=[0,False,None] ----> False 
    any(iterable)

all() - Check if eveything is true 
    all() retrun true only if all elemts are truthy 
    Retrun False if any one element is false 

    all(iterable)

    nums=[1,2,3]
    print(all(nums)) ----True 

    nums=[1,0,3]
    print(all(nums)) -----> false 

    fields=["name","email",""]
    print(all(fields))


map() - Apply Function to every element 

    - map() applies a function to each elelemnt
    - retrun a map object (covert to list to get output)
    - Used Transormataion 


    map(function,iterable)

    nums=[1,2,3,4]
    result=map(lambda x:x*x,nums)

    Note: Return Map --- To see the output we need convert it to List 

filter() - Select Elements based on condition 

    - filter() keeps elelemts where condition is True
    - Used for filtering/removing unwanted data 
    
    filter(function,iterable)

    nums=[1,2,3,4,5,6,7,8,9]
    even=filter(lambda x:x%2==0,nums)
    print(list(even))

    map()            and        Filter()
    Transfrorm                  select 
    same as input               samller or equal 
    Not requied                 Required 
    Modify data                 Remove Data 




7. Conversion & useful patterns : ( list(),join,flatten,dedupe)

    list() - Conversion pattern 
    - convert an iterable into list 
    - common Sources - map,filter,zip,range,generator experssion 

    name=["Amit","Neha"]
    marks=[80,90]
    pairs=list(zip(name,marks))
    print(pairs)

Join() - Join itrable of string ( String Joining pattern)
    - Join iterable of trings into single string 

    words=["Python","is","awesome"]
    senetence=" ".join(words)
    print(senetence)

Flatten- Nested Data Pattern 
    - Convert nested list ---- Flat List 

    matrix=[[1,2],[3,4],[5,6]]
    




---------------------------------------------------------------------------------------------------------------------------------------


Tuple
Set
Dictionary
String operations

---------------------------------------------------
index 0     1   2   3
Nums  5     1   4   2

Rule: Compare left number with right number 
If left>right---> Swap 

ROUND -1 

We compare all neighbors 

Step 1 : Compare index 0 & 1 

5  1   4   2
-  -

5>1--> true ---> Swap 

[1  5   4   2]

Step: compare index 1 & 2 

1  5   4   2
   -   - 

5 > 4 --> true ---> Swap 

[1  4   5   2]


Step 3 : Compare 2 & 3 

1  4   5   2
       -   - 
5>2 -- True --- Swap 

[1  4   2   5 ]

-> End of round 1 
-> Biggest number 5 moved to the end 


ROUND 2 (i=1)

ignore last element ( Already sorted)

step 1: comapre index 0 & 1 

1   4   2   5
-   -

1 > 4 --> False ---> No Swap 

[1  4   2   5]

Step 2 : Comapre index 1 & 2 

1   4   2   5
    -   -

4 > 2 --- True --  Swap 

[1  2   4   5]

End of Round 2 

[1  2   4   5]


ROUND 3 : (i=2)

Only First two elements need check 

Step 1 ; Comapre index 0 & 1 

1   2   4   5
-   -

1 > 2 --- False ---> no Swap 


[1   2   4   5]


ROUND 4 ( i=3 )

No Comaparision requied 



Final Result [1   2   4   5]



why n-i-1 


--> After each round, elements at the risght end are fixed 

round 1 [?  ?   ?   5]

round 2 [?  ?   4   5]

round 3 [?  2   4   5].  ------> We stop checking those fixed position 


Comapre neighbors ----> Swap ----> Reapt 
Big number move it right 

Samll number move left 


1. Bubble Sort 

2. Selection sort 

3. Insertion sort 

4. Merge sort 

5. Quick sort 

6. Heap sort 


lst=[[1,2,3],[4,5,6],[7,8,9]]
print(lst[0:1][0])




